# Lesson 53: URL Parsing

URLs provide a uniform way to locate resources. Here’s how to parse URLs in Go.

```
package main

import "fmt"
import "net"
import "net/url"

func main() {

    s := "postgres://user:pass@host.com:5432/path?k=v#f"

    u, err := url.Parse(s)
    if err != nil {
        panic(err)
    }
    
    fmt.Println(u.Scheme)
    
    fmt.Println(u.User)
    fmt.Println(u.User.Username())
    p, _ := u.User.Password()
    fmt.Println(p)

    fmt.Println(u.Host)
    host, port, _ := net.SplitHostPort(u.Host)
    fmt.Println(host)
    fmt.Println(port)
    
    fmt.Println(u.Path)
    fmt.Println(u.Fragment)
    
    fmt.Println(u.RawQuery)
    m, _ := url.ParseQuery(u.RawQuery)
    fmt.Println(m)
    fmt.Println(m["k"][0])
}
```

We’ll parse this example URL, which includes a scheme, authentication info, host, port, path, query params, and query fragment.

Parse the URL and ensure there are no errors.

Accessing the scheme is straightforward.

User contains all authentication info; call Username and Password on this for individual values.

The Host contains both the hostname and the port, if present. Use SplitHostPort to extract them.

Here we extract the path and the fragment after the #.

To get query params in a string of k=v format, use RawQuery. You can also parse query params into a map. The parsed query param maps are from strings to slices of strings, so index into [0] if you only want the first value.

Running our URL parsing program shows all the different pieces that we extracted.

```
$ go run url-parsing.go 
postgres
user:pass
user
pass
host.com:5432
host.com
5432
/path
f
k=v
map[k:[v]]
v
```
