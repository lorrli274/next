## Go by Example: Regular Expressions

Go offers built-in support for [regular expressions](https://en.wikipedia.org/wiki/Regular_expression). Here are some examples of common regexp-related tasks in Go.

This tests whether a pattern matches a string.
```go
    match, _ := regexp.MatchString("p([a-z]+)ch", "peach")
    fmt.Println(match)
```


Above we used a string pattern directly, but for other regexp tasks you’ll need to `Compile` an optimized `Regexp` struct.
```go   
    r, _ := regexp.Compile("p([a-z]+)ch")
```


Many methods are available on these structs. Here’s a match test like we saw earlier.
```go
    fmt.Println(r.MatchString("peach"))
```


This finds the match for the regexp.
```go
    fmt.Println(r.FindString("peach punch"))
```


This also finds the first match but returns the start and end indexes for the match instead of the matching text.
```go
    fmt.Println(r.FindStringIndex("peach punch"))
```


The `Submatch` variants include information about both the whole-pattern matches and the submatches within those matches. For example this will return information for both `p([a-z]+)ch` and `([a-z]+)`.
```go
    fmt.Println(r.FindStringSubmatch("peach punch"))
```


Similarly this will return information about the indexes of matches and submatches.
```go
    fmt.Println(r.FindStringSubmatchIndex("peach punch"))
```


The `All` variants of these functions apply to all matches in the input, not just the first. For example to find all matches for a regexp.
```go
    fmt.Println(r.FindAllString("peach punch pinch", -1))
```


These `All` variants are available for the other functions we saw above as well.
```go
    fmt.Println(r.FindAllStringSubmatchIndex(
        "peach punch pinch", -1))
```


Providing a non-negative integer as the second argument to these functions will limit the number of matches.
```go      
    fmt.Println(r.FindAllString("peach punch pinch", 2))
```


Our examples above had string arguments and used names like `MatchString`. We can also provide `[]byte` arguments and drop `String` from the function name.
```go
fmt.Println(r.Match([]byte("peach")))
```


When creating constants with regular expressions you can use the `MustCompile` variation of `Compile`. A plain `Compile` won’t work for constants because it has 2 return values.
```go
    r = regexp.MustCompile("p([a-z]+)ch")
    fmt.Println(r)
```
   
   
The `regexp` package can also be used to replace subsets of strings with other values.
```go
    fmt.Println(r.ReplaceAllString("a peach", "<fruit>"))
```


The `Func` variant allows you to transform matched text with a given function.
```go
    in := []byte("a peach")
    out := r.ReplaceAllFunc(in, bytes.ToUpper)
    fmt.Println(string(out))
```
Below is an example of the program output:
```go
$ go run regular-expressions.go 
true
true
peach
[0 5]
[peach ea]
[0 5 1 3]
[peach punch pinch]
[[0 5 1 3] [6 11 7 9] [12 17 13 15]]
[peach punch]
true
p([a-z]+)ch
a <fruit>
a PEACH
```

For a complete reference on Go regular expressions check the [regexp](https://golang.org/pkg/regexp/) package docs.

Next example: *JSON*. 
